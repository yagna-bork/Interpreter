/* Parser.java */
/* Generated By:JavaCC: Do not edit this line. Parser.java */
import java.util.*;

/*
* FOR DOCUMENTATION PURPOSES, "Extending code:" indicates
* areas to consider when trying to extend the code
*/

class Parser implements ParserConstants {
  public static void main(String[] args) {
    Parser p = new Parser(System.in);
    //start point of application

    try {
      //parsing
      p.Start();
      //evaluation of result if parsing succeded
      int result = Function.functions.get("MAIN").evaluate(0);

      //no errors
      System.out.println("PASS");
      System.out.println(result);
    }
    /*
    * Extending code:
    * For throwing custom errors throw an
    * instance of CustomParseException
    */
    catch(CustomParseException e) {
      System.out.println("FAIL");
      System.err.println(e.getMessage());
    }
    catch (TokenMgrError e) {
      System.out.println("FAIL");
      System.err.println(e.getMessage());
    }
    //catches a recursion error
    catch(RecursionException e) {
      System.out.println("PASS");
      System.out.println("DIVERGENCE");
    }
    /*
    * Default javacc exceptions are decoded
    * into custom errors here
    */
    catch (ParseException e) {
      System.out.println("FAIL");

      ArrayList<String> expectedTokens = new ArrayList<String>();
      String nextTokenImage = e.currentToken.next.image;
      Token errCausingToken = e.currentToken.next;

      /*
      * Get tokens that were expected but not found
      */
      for (int i = 0; i < e.expectedTokenSequences.length; i++) {
        for (int j = 0; j < e.expectedTokenSequences[i].length; j++) {
          String b = e.tokenImage[e.expectedTokenSequences[i][j]];
          expectedTokens.add(b);
        }
      }

      /*
      * Decode javacc default error messages to
      * determine the catagory of error
      * and print the custom message for each catagory
      */
      if (expectedTokens.contains("<FNAME>") & nextTokenImage.equals("DEF")) {
          ShowErrorAndQuit("Function name must not contain MAIN or DEF and must be all upper case", errCausingToken.beginLine);
      }
      if (expectedTokens.contains("\u005c"DEF\u005c"")) {
        ShowErrorAndQuit("Function decleration must start with DEF (uppercase)", errCausingToken.beginLine);
      }
      if (expectedTokens.contains("<PARAM>") & (nextTokenImage.equals(" ")  ||
        nextTokenImage.equals("{")) || (nextTokenImage == nextTokenImage.toUpperCase())) {
          ShowErrorAndQuit(
            "HINT: Paramaters need to be Non-empty strings, "
              + "\u005cnLower-case characters,"
              +  "\u005cnContains empty spaces, "
              + "\u005cnInvalid call to MAIN, "
              + "\u005cnWhite space in paranthesis.",
              errCausingToken.beginLine);
      }
      if (expectedTokens.contains("<FNAME>") & expectedTokens.contains("<DIGITS>") & expectedTokens.contains("<PARAM>") & nextTokenImage.equals(" ")) {
        ShowErrorAndQuit("The function cannot be empty.", errCausingToken.beginLine);
      }
      if (expectedTokens.contains("<FNAME>") & expectedTokens.contains("<DIGITS>") & expectedTokens.contains("<PARAM>") & nextTokenImage.equals("(")) {
        ShowErrorAndQuit("Parenthesis can only be present in function calls.", errCausingToken.beginLine);
      }
      if (expectedTokens.contains("\u005c"}\u005c"")) {
        ShowErrorAndQuit("White spaces are not allowed in the expression body.", errCausingToken.beginLine);
      }
      System.err.println("Unknown parser error");
      System.exit(-1);
    }
    catch(Throwable e) {
      System.out.println("FAIL");
      System.err.println("Unknown program error (not a parser error)");
    }
  }

  /*
  * After an error condition has been matched
  */
  private static void ShowErrorAndQuit(String err, int line)
  {
    System.err.println("Line: " + line);
    System.err.println(err);
    System.exit(-1);
  }

  static final public void Start() throws ParseException, ParseException, RecursionException {
    label_1:
    while (true) {
      FunctionProd();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DEF:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
    }
    jj_consume_token(0);
if(!Function.functions.containsKey("MAIN")) {
      {if (true) throw new CustomParseException("MAIN function not defined");}
    }

    //check undefined function not called
    for(FCallEdge edge: FCallEdge.allFCallEdges) {
      if(!Function.functions.containsKey(edge.getEnd())) {
        {if (true) throw new CustomParseException(String.format("Undefined function '%s' is referenced " +
          "in function '%s'", edge.getEnd(), edge.getStart()));}
      }
    }
  }

  static final public void FunctionProd() throws ParseException, ParseException {Token t;
  String fName;
  String pName;
  Expression expression;
  Function f;
    jj_consume_token(DEF);
    jj_consume_token(S);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case MAIN:{
      jj_consume_token(MAIN);
      jj_consume_token(S);
      jj_consume_token(LCB);
      jj_consume_token(S);
      expression = ExpressionProd("MAIN", null);
      jj_consume_token(S);
      jj_consume_token(RCB);
f = new Function(expression, "MAIN"); //NONE as parameter name implies its MAIN so no parameters

      break;
      }
    case FNAME:{
      t = jj_consume_token(FNAME);
fName = t.image;
      jj_consume_token(S);
      t = jj_consume_token(PARAM);
pName = t.image;
      jj_consume_token(S);
      jj_consume_token(LCB);
      jj_consume_token(S);
      expression = ExpressionProd(fName, pName);
      jj_consume_token(S);
      jj_consume_token(RCB);
f = new Function(expression, fName);
      break;
      }
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
if(Function.functions.containsKey(f.getFName())) {
      {if (true) throw new CustomParseException(String.format("Function '%s' defined more than once", f.getFName()));}
    }
    else {
      Function.functions.put(f.getFName(), f);
    }
    jj_consume_token(S);
    jj_consume_token(SC);
    jj_consume_token(EOL);
  }

  static final public Expression ExpressionProd(String startFName, String functionPName) throws ParseException {ArrayList<Multiplication> multiples = new ArrayList<Multiplication>();
  Multiplication multiple;
    multiple = TermProd(startFName, functionPName);
multiples.add(multiple);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:{
        ;
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      jj_consume_token(PLUS);
      multiple = TermProd(startFName, functionPName);
multiples.add(multiple);
    }
Expression e = new Expression(multiples);
    {if ("" != null) return e;}
    throw new Error("Missing return statement in function");
  }

  static final public Multiplication TermProd(String startFName, String functionPName) throws ParseException {Val v;
  ArrayList<Val> Vals = new ArrayList<Val>();
    v = ValProd(startFName, functionPName);
Vals.add(v);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MUL:{
        ;
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        break label_3;
      }
      jj_consume_token(MUL);
      v = ValProd(startFName, functionPName);
Vals.add(v);
    }
Multiplication m = new Multiplication(Vals);
    {if ("" != null) return m;}
    throw new Error("Missing return statement in function");
  }

  static final public Val ValProd(String startFName, String functionPName) throws ParseException {Token t;
  FCall fCall;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DIGITS:{
      t = jj_consume_token(DIGITS);
Digits d = new Digits(Integer.parseInt(t.image));
      {if ("" != null) return d;}
      break;
      }
    case FNAME:{
      fCall = FCallProd(startFName, functionPName);
{if ("" != null) return fCall;}
      break;
      }
    case PARAM:{
      t = jj_consume_token(PARAM);
if(!functionPName.equals(t.image)) {
        {if (true) throw new CustomParseException(String.format("Invalid parameter name '%s' "
          + "used inside function '%s'", t.image, startFName));}
      }
      Param p = new Param();
      {if ("" != null) return p;}
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public FCall FCallProd(String startFName, String functionPName) throws ParseException {Token t;
  Expression expression;
    t = jj_consume_token(FNAME);
    jj_consume_token(LPB);
    expression = ExpressionProd(startFName, functionPName);
    jj_consume_token(RPB);
FCall fCall = new FCall(t.image, expression, startFName);
    FCallEdge.allFCallEdges.add(new FCallEdge(startFName, t.image));/* Create a FCallEdge for this call••••••••• */
    {if ("" != null) return fCall;}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public ParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[5];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x80,0x1002,0x10,0x20,0x7000,};
   }

  /** Constructor with InputStream. */
  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Parser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Parser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Parser(ParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[18];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 5; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 18; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}

/*
* Extending code: Any feature that may require checking for recusion
* check for recusion and
* throw this class when such recusion is detected,
* to work with existing code
*/
class RecursionException extends Exception {
  public RecursionException(String message) {
    super(message);
  }

  public RecursionException() {
    super();
  }
}

/*
* Extending code: Any new feature
* resulting in a parse exception
* must throw this error upon parse error being detected
*/
class CustomParseException extends ParseException {
  public CustomParseException(String message) {
    super(message);
  }
  public CustomParseException() {
    super();
  }
}

/*
* Extending code:
* A new feature class must implement this
* interface to allow it to work with old code
*/
interface iEvaluable {
  /*
  * Return the int that a component of
  * a statement in PLM can resolve to
  */
  int evaluate(int pVal) throws ParseException, RecursionException;
}

/*
* Class representing the function product defined in the parser.
* A class is used so Function objects
* can be stored later, representing
* a function production, and called upon later during runtime execution.
* Root node of the following abstract syntax tree
*/
class Function implements iEvaluable {
  /* Store all functions globally */
  public static HashMap<String, Function> functions = new HashMap<String, Function>();
  /* Top level expression for function production */
  private Expression rootExpression;
  private String fName;

  public Function(Expression rootExpression, String fName) {
    this.rootExpression = rootExpression;
    this.fName = fName;
  }

  public int evaluate(int pVal) throws ParseException, RecursionException {
    return rootExpression.evaluate(pVal);
  }

  public String getFName() {
    return this.fName;
  }
}

/*
* Extending code:
* Any new feature class that
* can directly return an int Val
* must implement this interface to work with old code
*/
interface Val {
  int getVal(int param) throws ParseException, RecursionException;
}

/*
* Class represent literal integer value in PLM
* that can be directly evaluated to a positive
* integer. Hence it implements Val interface
*/
class Digits implements Val {
  private int Val;

  public Digits(int Val) {
    this.Val = Val;
  }

  public int getVal(int pVal) throws ParseException, RecursionException {
    return Val;
  }
}

/*
* Represents the numerical value that
* a expression production evalutes too
*/
class Expression implements iEvaluable {
  private ArrayList<Multiplication> multiplications;

  public Expression(ArrayList<Multiplication> multiplications) {
    this.multiplications = multiplications;
  }

  /*
  * A expression at the top level consists of a sum of
  * multiplications which is calculated by sum of array
  * operation
  */
  public int evaluate(int pVal) throws ParseException, RecursionException {
    int total = 0;
    for(Multiplication m: multiplications) {
      total += m.evaluate(pVal);
    }
    return total;
  }
}

/*
* Class represent value of
* sequence of multiplications
* constructed from a multiplaction production
*/
class Multiplication implements iEvaluable {
  private ArrayList<Val> Vals;

  public Multiplication(ArrayList<Val> Vals) {
    this.Vals = Vals;
  }

  public int evaluate(int pVal) throws ParseException, RecursionException {
    int total = 1;
    for(Val v: Vals) {
      total *= v.getVal(pVal);
    }
    return total;
  }
}

/*
* Object constructed when a call from Function(start)
* is made to Function(end).
* Acting as a connection between AST of two Function
* objects
*/
class FCallEdge {
  public static Set<FCallEdge> allFCallEdges = new HashSet<FCallEdge>();
  private String start;
  private String end;

  public FCallEdge(String start, String end) {
    this.start = start;
    this.end = end;
  }

  public String getStart() {
    return start;
  }

  public String getEnd() {
    return end;
  }

  /*
  * Manually define how to determine two
  * FCallEdges
  */
  @Override
  public int hashCode() {
    return (start + end).hashCode();
  }

  @Override
  public boolean equals(Object e2) {
    if(e2 instanceof FCallEdge) return this.hashCode() == e2.hashCode();
    return false;
  }
}

/*
* Represents a fcall prod
* from the parser below
*/
class FCall implements Val {
  private String startFName;
  private String fName;
  private Expression argExpression;
  /* Stores current stack of unfinished functions */
  public static Stack<FCallEdge> currentlyExecuting = new Stack<FCallEdge>();

  /*
  * A FCall consists of the start function (fName) that calls
  * another function startFName
  */
  public FCall(String fName, Expression argExpression, String startFName) {
    this.fName = fName;
    this.argExpression = argExpression;
    this.startFName = startFName;
  }

  /*
  * The numerical value of a function call
  * is calculated by evaluating
  * startFName with the provided argExpression
  */
  public int getVal(int pVal) throws ParseException, RecursionException {
    FCallEdge edge = new FCallEdge(startFName, fName);
    /* If current function call goes to a function
    which hasn't yet been completed, then there is a
    cycle in the graph of function calls.
    Stack stores functions that haven't been finished yet */
    if (!(this.currentlyExecuting.search(new FCallEdge(edge.getEnd(), edge.getStart())) > -1)) {
      this.currentlyExecuting.push(edge);

      int argVal = argExpression.evaluate(pVal);
      Function f = Function.functions.get(fName);
      int val = f.evaluate(argVal);

      this.currentlyExecuting.pop();
      return val;
    }
    else {
      throw new RecursionException(String.format("Recursion detected %s->%s", startFName, fName));
    }
  }
}

/*
* Represents a param within
* a expression production
*/
class Param implements Val {
  public int getVal(int pVal) throws ParseException, RecursionException {
      return pVal;
  }
}
